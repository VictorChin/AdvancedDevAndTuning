<html>

<head>

  <title>Cursor reuse in PL/SQL static SQL</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">

  <meta name="Author" content="Bryn Llewellyn">
  <link rel="stylesheet" href="../Content.css" type="text/css">
</head>


<body><div class="Content_Div">
<h2>Demonstrating the LRU behavior of the PL/SQL cursor cache</h2>


Consider this trivial program,
<a href="Cr_Open_Close_5_Different.htm">
<tt>Open_Close_5_Different</tt></a>.
Had it not been for the discussion above, you might think that
you would see no trace of its cursors in

<tt>v$open_cursor</tt>
when it exits.
Compile and run it, and observe it from another session as
<tt>observer</tt> above.
You'll see...<pre class="Code_Emphasize">BEGIN Open_Close_5_Different; END;
SELECT '001' from dual

SELECT '002' from dual
SELECT '003' from dual
SELECT '004' from dual
SELECT '005' from dual</pre>
...which we now understand as reflecting the fact
that the cursors were in fact only soft-closed.
<p>

The source for the program,
<a href="Cr_Open_Close_5_Different.htm">
<tt>Open_Close_5_Different</tt></a>
was in fact generated by running the program
<a href="Cr_Generate_Open_Many_Cursors.htm">
<tt>Generate_Open_Many_Cursors</tt></a>
thus...
<pre class="Code_Emphasize">begin Generate_Open_Many_Cursors (

  p_number=>5, p_close=>true, p_same_sql=>false ); end;</pre>
...(more on <tt>p_close</tt> and <tt>p_same_sql</tt> presently. Now find 
    out the limit on the number of cursors your session can open...
  <pre class="Code_Emphasize">select value from v$parameter
  where name='open_cursors'
</pre>
  ...and build a program to excede that limit.
(If you're the DBA, set the limit low to make this experiment less verbose.)
For example, if your

<tt>open_cursors</tt> 
is 300, then build
<tt>Open_Close_305_Different</tt>
by invoking
<a href="Cr_Generate_Open_Many_Cursors.htm">
<tt>Generate_Open_Many_Cursors</tt></a>
with
<tt>p_number=>305</tt>.
Check it's what you expect
thus...

  <pre class="Code_Emphasize">select text from user_source
  where name = Upper('Open_Close_305_Different') order by line
</pre>
  ...reconnect, and execute it. Observe
<tt>open_cursor_sql_text</tt>
from another session. You should see that the 
PL/SQL cursor cache is full,
that the last few cache slots correspond
to the cursors from the last few
<tt>open</tt>
statements and that

the slots corresponding to the cursors from the first few
<tt>open</tt>
statements have been re-used LRU style.
<p>
Now rebuild your program using
<tt>p_close=>false</tt>
which will generate for example
<tt>Open_305_Different</tt>.
Execute it. You'll get
<i>ORA-01000: maximum open cursors exceeded</i>.
Observe
<tt>open_cursor_sql_text</tt>

again. You should see that the 
PL/SQL cursor cache is full again, but that
the slots show cursors corresponding
the first consequetive
<tt>open</tt>
statements until the limit is hit.
<p>
These two tests
<tt>Open_Close_305_Different</tt> and
<tt>Open_305_Different</tt>
clearly show the effect of the PL/SQL
<tt>close</tt>
statement as a soft-close.

<p>
<font color=red><b>You should always
<tt>close</tt>
a PL/SQL static SQL cursor
immediately after you have finished fetching from it.</b></font>
<p>
There is <b><i>never</i></b> any reason for not following this guideline.
<p>
<i>Note:</i> If you program badly and omit the
<tt>close</tt>
statement corresponding to a given
<tt>open</tt>
then the PL/SQL runtime system will generally rescue you
by doing the close for you as soon as

the identifier for the cursor goes out of scope.
(The close will be either soft of hard
depending on the nature of the cursor. More on this later.)
However, there are certain circumstances where this does not happen
(reflecting a trade-off in the design
of the PL/SQL runtime system between robustness
against badly written code and speed of execution).
Oracle Corporation does not document these subtle rules
(they might change with successive versions).
<p>
If you insist on knowing what's not good for you to know<i>(!)</i>, at Oracle9<i>i</i>, a cursor
for which you omit the
<tt>close</tt>
statement will generally be closed when the block in
which it was declared goes out of scope

provided that this block is either named (a function or procedure)
or is the top-level anonymous block invoked by the client.
This rescue is deferred for a nested anonymous block
until the enclosing named block or
top-level anonymous block is exited.
</div></body></html>

